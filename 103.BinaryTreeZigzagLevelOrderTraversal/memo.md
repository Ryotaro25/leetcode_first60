## ステップ1
vectorで処理するnodesと次の階層のnodesを管理すれば階層ごとのnodeを処理きる
~~前からなのか後ろからなのかをループごとに管理するflgを管理すれば解けそう~~
途中で階層が奇数か偶数かで判断すれば解けると気づいた
新しくflgという情報を設けるより、階層を使う方が素直だと感じたのでこちらを採用

候補のNodeを突っ込む際なのか、階層ごとに値を纏める時にジグザク処理するのかが詰まった
acceptまで22分
時間計算量
O(n log n)
空間計算量
O(n)

## ステップ2
・右からの並び替えのタイミングを変更
  values(vector)に要素を突っ込む際に、奇数偶数に合わせて前後に振り分けていたが
  valuesからlevel_to_zigzag_valuesに入れる際に奇数偶数に合わせてvaluesの順序を反転させる


## 他の方の回答
・dequeを使って管理することもできる
https://github.com/TORUS0818/leetcode/pull/29/commits/f657cc123ccec9436321d91e35725c32368d74ac
他にもタイトルの通りジグザグに探索する方法もある
>取り出す方向(pop/pop_left)、子を追加する順序(right/left)があって混乱しやすいかもしれない
この方の他の解法に比べて理解に時間がかかった。追うものが多いから？

・右から追加する場合にはリストを反転させる
  https://github.com/fhiyo/leetcode/pull/29/commits/2b87eb71a099fd4577dcd772744274815431ad90
  >右からのときはリストを反転させるパターン。難しく考えず、こういう解法を選択肢として出せるようにしておきたい。　
  すごく綺麗に処理されていて読みやすかった
  Nodeを集める際に並び替えながら候補に突っ込むのか、
  一旦候補に突っ込んでから頭orお尻から取り出すのか等とまさに難しく考えていたのですごく参考になりました。

・RustだとMatchが存在する
　https://github.com/Yoshiki-Iwasa/Arai60/pull/31/commits/9691fbd6e804c4dc06ddd286c6e09862b5a5a1c4
　調べてみたけどC++だとif-elseかswitch分

## 他の解法
・deque
  c++にもdequeがあったのでドキュメントを読んで使ってみた
  deque.cppに実装
  取り出し時とdequeへの挿入時が、関数名も相まってすごく読みにくくなってしまった