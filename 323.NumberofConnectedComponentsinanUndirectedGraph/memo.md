## ステップ1
エッジ同士が繋がっている配列みたいなものを作ってNodeを0からNまで確認すれば解ける？
トータルのノード数から、上記のエッジ数を引けば答えが出ると思う

繋がっているエッジの管理方法がわからなかったので回答確認
https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/solutions/5422761/simple-c-solution-bfs-beats-89-of-users/
visitedと言う変数で管理する
=>訪問済みと言うのは、対象のNodeと隣接しているNodeを順に見ていった結果訪問済み
　つまり繋がっているから訪問済みとなる
　未訪問のNodeがあると上記同様対象Nodeと隣接Nodeを訪問し訪問済みの印をつける
　それ以降は訪問済みのマークが付いているのでそれまでのいずれかのedgeに含まれている

## ステップ2
改善点など
・C++の関数はアッパーキャメルでは？
  関数名をアッパーキャメルに変更

・visitedをSolutionクラスのメンバー変数にする
  関数の引数が多い?気がしたため
  →変数のスコープは出来るだけ短い方が読みやすいと他の方への指摘にあった
   今回は処理全般にわたって使うので、スコープは変わらないのでスリムにかけていいと思う

・intはそこまで気にする必要がないとのことなので、node間の連携しているconnected_edgesは変更できない参照にしてみた
　メモリ意識

想定質問
・constをつけるタイミングは？
  effectivec++3項より
    可能ならいつでもconstを使う(他のプログラマとコンパイラに変更しないものと宣言できる)
    対プログラマに対しては、constをつけたオブジェクトや関数への理解度を上げることにとつながる
    コンパイラの側面からは、ビットレベルの不変性につながる(ルール違反があるとエラー通知される)
  
  effectivec++20項より
    const参照渡しにすることで、毎回コピーが生成されるのを防ぐ、引数の値を変更するのを防ぐ
    組み込み型(int, void...)やstlのイテレーターは値渡しを使う、値渡しであっても効率が悪くないため

レビュー
・引数のうち、 CPU の汎用レジスターのサイズを超えるサイズの値は、 const 参照
　汎用レジスターのサイズは=>32ビットや64ビット
　汎用レジスタの目的は、主にプログラマが使い変数としてのメモリです
　基本的には、データの格納など、何に用いてもかまわない領域です
  https://wisdom.sakura.ne.jp/programming/asm/assembly3.html　

## 他の解法
union-findでも解くことができる
前回の問題から異なる部分は、エリアのサイズを計算するのではなく
単純にUnionできるかどうか＝Node同士が繋がっているかどうか
これまでの問題で1番UnionFindがしっくりきた

UnionFindを使えばステップ１で思いついた、
コンポーネントの集合体を作ってその数だけNから引くことで答えが出る

## Discordや他の方の回答など
変数のスコープはできるだけ短くできないか確認する
https://github.com/goto-untrapped/Arai60/pull/35/files#diff-5069ccf62e38900b244adf5253263b30f533ab0bbaa39331452c0c87a1e1227c

くっつけた回数、くっついているedgeの数を引く方法がある
この方法はunion findでやる方がしっくりくる
https://github.com/TORUS0818/leetcode/pull/21/files?short_path=f22c084

https://github.com/Yoshiki-Iwasa/Arai60/pull/21#discussion_r1663604348