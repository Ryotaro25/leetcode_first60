## ステップ1
sが空の場合は、t内の文字を全て削除すれば作れるのでtrueですよね？

思いついた方法は愚直にsをループで回し、tが含まれるのかチェック。
tのインデックスを記憶しておき、sの次の文字の探索開始位置をそこにする。
sの長さをm
tの長さをn
これだとO(m n) 10^4 * 100 なので10^6か

queueを使えば、二重ループにしなくても解けそう。
>without disturbing the relative positions of the remaining characters.
問題文に丁寧にこう書いてあるので、queueが向いてる。
sの文字を順番に突っ込む。tを頭から探索して一致する文字があればqueueから取り出す。
最終的にqueueが空かどうかでとく。
tの長さに釣られて
時間計算量O(n)
空間計算量O(n)

## ステップ2
step1に対して
queueに突っ込んだがforループで見ていく場合は前から見ていくので
queueにつっこむ意味はない
sの文字を見ていくのではなく、indexを見ていく
tを頭から見ていき、s[index]が現れた場合のみsのindexを更新する

leetcodeの解答より
バイナリーサーチ、グリーディー、ダイナミックプログラミングで解くことができる。
=>どの回答もstep1の選択肢を考える際に思いつかなかった。

・divide.cppを実装
  一文字ずつに分解して、sがtに含まれるのか再帰的に探索する
  文字をのまま渡すのではなく添字で管理する。
  
  sとtの先頭文字が一致すれば、sの添字を進める。そうでなければスキップする。
  再帰呼び出しのたびにtの添字は進める。
  時間はO(n)で、空間はO(n)で解くことができる。

・two_pointers.cpp
  divide.cppだと再帰呼び出しのたびにスタックメモリを使用する(関数の戻り先か)ので再帰を使わずループに変更。
  =>この解法は初見で思いつきたかった。
  ループのたびにtを探索する添字はインクリメントする。
  sを探索する添字は探索中の文字が一致した場合のみとする。
  最終的にsの添字がsの長さと一致していれば、Subsequenceを作ることができるということ。
  時間はO(n)で、空間はO(1)で解くことができる。

・map.cpp
 s側ではなくt側をmapに突っ込み文字に対する出現位置を全て入れる
 sを頭から一文字ずつ確認する。
 登場位置の制約を守りながら、全ての文字が登場するかどうかを確認することで解ける。
 この方法であれば毎回t全体を探索することを避けることができる。

## ステップ3
**3回書き直しやりましょう、といっているのは、不自然なところや負荷の高いところは覚えられないからです。**

## 他の方の解法
>std::vector については何度か議論があったと思います。それらを意識したうえで使うのであれば大丈夫だと思います。過去のコメントを探してみることをお勧めいたします。
今回は使っていないが、vector<bool>の特殊化については認識しておく
https://cpprefjp.github.io/reference/vector/vector.html

>setを使う場合はcharacterPositionsの初期化がO(N)ではなくO(NlogN)になりそうかなと思ったのですが、
insertする際の計算量見落としがちなので意識する。
・size_tを使うかintを使いかは文脈次第
  過去の問題で受けたsize_tは, unsigned intであるということを意識して使う

>競合状態を避けるため、副作用のある書き方は現実的な範囲でできるだけ避けたほうがよいと思います。
leetcodeだけの話だと見落としてしまいち
https://github.com/usatie/leetcode/pull/5/files/db0790afcbe0e57e141f025f902c1226890976b6#diff-96848deece2c6608d931aa2cb2aaf0ffd78c9fc4cd7337d89293dba090c204af


>s, t はどっちがどっちか分からないので避けたいですね。
書き換えられる範囲で意識しよう
https://github.com/philip82148/leetcode-arai60/pull/7

選択肢としてはhashmap、dp、two pointersか
https://github.com/Yoshiki-Iwasa/Arai60/pull/62/commits/09cc9ca0456c7df9c0f875c387207bc61727c787

辞書と二分探索を混ぜた解法
一見単純な問題でも選択肢たくさんあるんですね。
https://github.com/fhiyo/leetcode/pull/55/commits/3bdbb38c39f00eba0213b5fb82d1cddd75e55537

## Discorなど

