## ステップ1
ぱっと見で思いついたのは総当たり
0(n^2) = (10^5)^2 = 10^10 = 10,000,000,000
調べると基準値は10^8 これはPCが1秒間に処理できる大きさが10^8だから？
この辺りソースなど参考になるものございましたら教えていただきたいです。

vectorを作ってnumsを一つずつ進めながら部分ごとの合計をとる
やはりDPを使った時の、値の更新方法が分からなかった

一旦「なっとくアルゴリズム」と「アルゴリズムイントロダクション」のDP関連部分を再度読んで再チャレンジ
現在いる箇所の値とその地点までの合計＋現在いる箇所の値がどちらが大きいのか比較する。
現在いる箇所の値だけを選択する＝最大化のための配列の開始位置をリセット

区間ごとの最大値はvector内に保存しているので
降順に並べ替えた一つ目の要素が最大値となっている

時間計算量
O(n)

空間計算量
O(n)

## ステップ2
・最大値を保有する変数追加
  コード量はそんなに多くないので、vectorを降順に並べた一つ目の要素を返すより直感的だと思う
・制約的にありえないがnumsが0の場合も考慮

  コピーを発生させないために要素の追加方法をpush_backに変更してもいいけど
  indexの位置を理解することがコードを理解することに繋がりそうなので今回は良さそう
  一般的にintはそこまでコストが大きくない

基本方針は同じ。
現在の部分列を継続するか、新しくsumを求めるか
累積和を使う選択肢がある。
https://github.com/Yoshiki-Iwasa/Arai60/pull/48
https://discord.com/channels/1084280443945353267/1206101582861697046/1208414507735453747
https://discord.com/channels/1084280443945353267/1183683738635346001/1192145962479665304
自分の場合問題のジャンルを見て、思考がDPによってしまい思考停止してしまっている。。。

if (nums[i - 1] > 0)の場合nums[i]を更新する方法
leetcodeのsolution内にもこの解放が多数あったけど、これが成り立つ理由がよくわからなかった
>前の要素が正であれば、部分列を延長することでその合計を増やせると考えています。(chatgpt)
個人的にはそれまでの部分合計と比較したくなる
https://github.com/rossy0213/leetcode/pull/17/commits/0d75ba2e08fad2ffd541e21bab118270f8c9a228

基本方針は同じで、更新の条件が自分のと異なる
再帰で求める方法もある
https://github.com/fhiyo/leetcode/pull/33

常に最大値を覚えておけばいいので、vectorを使わないで空間O(1)でも解ける
https://github.com/goto-untrapped/Arai60/pull/30/commits/88cd60fdfcfc076ea65ddfdb68dcecb9fee18212

## ステップ3
下記を見落としていて、今日まで漠然と(作業のように)書いていた。改めよう。
**3回書き直しやりましょう、といっているのは、不自然なところや負荷の高いところは覚えられないからです。**

## 他の解法
累積わで解いてみる
cumulative sumで実装


## Discordなど

