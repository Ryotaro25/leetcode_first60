## ステップ1
あらかじめ区間ごとの合計を求めておいて、kになる部分をカウントすればいいので
累積和で解く。AtCoder勉強時に同様の問題を複数回解いていたので条件反射的に判断した

累積和を使わない方法を考えてみたが、複数ループを用いる際に打ち止めポイントが分からなかった。
計算量誤っておりました。
時間計算量
O(n^2)

空間計算量
O(n)

## ステップ2
累積和について、パターンで覚えているので他の解放を調べてみた
理解というより暗記しているのでドキュメントを探してみる


## 他の解法
hash mapを使った方法
前から順番にsumを求めて、sumをkeyに登場回数をvalueとする
hash_map.cppに実装
https://leetcode.com/problems/subarray-sum-equals-k/solutions/1760146/c-easy-solution-prefix-sum-map-easy-understanding-hashmap/

上記の解法に似ている
https://github.com/sakupan102/arai60-practice/pull/17/commits/cd96b2420ded8a784f2e8aefc90915eaa6d84c48

用語の統一やprefixに気をつける
https://github.com/fhiyo/leetcode/pull/19

## Discordなど
具体化して抽象を理解する
https://discord.com/channels/1084280443945353267/1183683738635346001/1192145962479665304
一度に複数のことを行うので難しい
問題を見た時に考えていることと意図
>1番上は思いついたけれども、価値のないものだと思って捨てたでしょう。そこがいかんのですよ。
1番上＝二重ループを使う解放
確かに捨てて、たまたま知っていたこの問題は累積和と飛びついた。

>見たときに大局的に色々な手段が見えていること。
>その中には遅いものも速いものもあり、色々な良し悪しで評価できること。例えば速度の見積もりとかもそれ。
>それぞれの手段の間の移り変わりの関係性が見えていること。
>局所的に変更して、見やすくしたり、整理したりすることができること。
https://discord.com/channels/1084280443945353267/1206101582861697046/1208414507735453747