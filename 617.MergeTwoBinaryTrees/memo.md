## ステップ1
ルール通りすごく愚直にかいた
一つ目のnodeを用いて値を足すのか、欠損しているnodeを足すのか判定を行った

node間がoverlapしている場合つまりどちらもnullptrではに場合は、値の足し算と探索候補としてqueueに追加
2つ目のnodeのみがnullptrでない場合は、1つ目のnodeを上書き

上記を2つのnodeの要素(node)がなくなるまでループさせて最終的に一つ目のnodeを返却
30分ほど掛かった
時間計算量
O(n)

空間計算量
O(n)
## ステップ2
・queueに追加するもしくは片方のnodeにmergeする部分を関数化(MergeOrPushQueue)
　2種類の作業を1つの関数で行っているのは微妙な気がする

・MergeOrPushQueueは外側から使われないのでprivate化
　TwoNodesはメンバー関数からのみのアクセスを許可するようにprivate化

## 他の解法
dfsで解くこともできる
dfs.cppに実装
この場合も
時間計算量
O(n)

空間計算量
O(n)

新しくnodeを作る方法
TreeNodeクラスがデストラクタをどのように定義しているのか気になるところ
左右のノードの処理は似ているので関数化出来そうだけど、可読性が下がりそうなのでやめた
左右のどちらを作業しているのかis_leftのような引数を持たせてこれの値によって処理分けを想定

## Discord他のPRなど
新しくnodeを作る方法もある何を持って選択肢たか意識する
>新しいのを作るか作らないのか、古い入力を壊すのか壊さないのか、共有するのかしないのか(変更しない前提ならばメモリー使用量が減る)、などのオプションがあって、自分がどれを「選択」したかを意識しましょう。
https://github.com/fhiyo/leetcode/pull/25
新しく作るという手段は思いついたけど、入力と分けて管理する必要性や新しくnodeを管理するコストを考えて
片方に追加していく方式にした。

https://github.com/nittoco/leetcode/pull/30
