## ステップ1
問題を見て思いついたのは
(m + n)!/m!n!の公式を使う解法と1マスごとに、ロボットが何パターンで進むことができたのか記録する方法。
今回は後者の方法で行う。右端に辿り着いた時点でのパターン数が解答になる。

時間計算量O(m n)
空間計算量O(m n)

## ステップ2
i jを使うかrow colを使うかは好みの問題か
空間計算量を抑えることはできる

## 参考にした他の方の解法
基本的は方針は同じ
~~数学的な解き方でも解いてみる。C++に階乗やコンビネーションのライブラリはなさそう。~~
数学的な解き方でも解いてみる。C++に階乗やコンビネーションの標準ライブラリはなさそう。
https://github.com/Yoshiki-Iwasa/Arai60/pull/47
combitation.cppに実装
扱う数字の大きさを抑える方法が分からなかったのでChat GPTに相談
combinationの第二引数には可能な限り小さい数値を渡すためにminを用いる
→たまたまLeetCodeのテストケースで通っただけのような気がする

行単位もしくは列単位でパターン数を記録することで空間計算量をO(m) もしくはO(n)に抑えることができる
ただ、コード面接でこれは思いつけそうにない
https://github.com/fhiyo/leetcode/pull/34
step4.cppに実装(写経)

## Discordなど

