## ステップ1
まず思いついたのはrootとは別に2つ新たにnodeを用意して、
targetより小さいものと大きいものをそれぞれのツリーを作りそれらをvectorに入れて返却する。

一旦プログラムを書いて上手く動かなかったので、答えを確認し1.5hほどでacceptできた。
理解出来ていなかった箇所はループの小さい側、大きい側のそれぞれに2回目以降に紐付ける場合の動き。
root = [4,2,6,1,3,5,7], target = 2の場合
val = 4 smaller_node [] larger_node [4,6,5,7]
val = 2 smaller_node [2, 1] larger_node [4,6,5,7]
val = 3 smaller_node [2, 1] larger_node [4,3,6,5,7] // 探索終了
ここで3をどのように大きい側に繋ぐのかは答えを確認した。

3つのnodeを使っているんのでそれぞれの値をどう更新するのか理解するのに時間がかかった。

時間計算量
O(n)
左右に偏っている場合

空間計算量
O(1)

## ステップ2
・変数名の修正
・理解するためにコメントを追記
・if文を反転

再帰でも実装recusive.cpp
構造体を使いたかったが、返却値に合わせて型変換を行う必要があるので今回はそのまま

## ステップ3
**3回書き直しやりましょう、といっているのは、不自然なところや負荷の高いところは覚えられないからです。**

## 他の方の解法
gotoさんは再帰の解法を用いている。

>手作業時にいきなりプログラムありきで解き方を考えている気がする
これは自分も本当にそうでかつ、ロジックから答えを導くのではなく答えからロジックを導こうとしている。

https://github.com/goto-untrapped/Arai60/pull/54/commits/570e2c2f1ee6ddcbdeaead4c40dbb2fb2a25d817

型名を決めるときの注意点
>型は何かをできなくするための制限なので、何をできないようにしたかと、そのメリットのバランスで決めるもの

>分割後のtreeはleft, rightよりsmaller, largerのほうが性質の違いが表現できていていいと思った
>戻り値がleft, rightだとどっちから見てleft, rightなのかわからなくなりそうと思った
小さい側(大きい側)のツリーにもleftとrightが存在するためsmaller largerが良さそう
https://github.com/Yoshiki-Iwasa/Arai60/pull/41

>2 個連続で入れるのは、トップレベルの関数や変数の間だけが良いと思います。
知らなかった。
https://github.com/Mike0121/LeetCode/pull/16

## Discordなど

