## ステップ1
一旦全てのnodeを分解して、つなぎ合わせる。
1からスタートするindexとnodeをmap内に記録して下記の3段階で繋げる。
・leftまでは昇順
・left ~ rightは降順
・rightの次から、最後までは昇順
時間計算量O(n)
空間計算量O(n)

## ステップ2
step2_1.cpp
step1に変数名の変更とコメントを追加したもの。

step2_2.cpp
stackを使った解法。
step2_1のmapを使った解法との違いは、left ~ right の部分だけをstackに保存し、
元のつながりを維持しながら反転部分だけつなぎ直している。
時間計算量O(n)
空間計算量O(n)
空間計算量は同じでもleft ~ rightが小さいとこちらの方が効率的か。

step2_3.cpp
step2_2のstackを使っている解法から直接nodeをつなぎ合わす方式に変更したもの
時間計算量O(n)
空間計算量O(1)
mapやstackを使わないので改善されているか

一つのループ内でnodeが3種類出てくるので処理を追うのが少し大変
近年のPCスペックだと空間計算量に対してそこまでシビアになる必要がないと聞くこともあるので
mapやstackに入れて管理した方が読みやすいと感じた。

## ステップ3
**3回書き直しやりましょう、といっているのは、不自然なところや負荷の高いところは覚えられないからです。**


